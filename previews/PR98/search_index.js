var documenterSearchIndex = {"docs":
[{"location":"api/function_index/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/function_index/#Contents","page":"API","title":"Contents","text":"","category":"section"},{"location":"api/function_index/","page":"API","title":"API","text":"Pages = [\"function_index.md\"]","category":"page"},{"location":"api/function_index/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/function_index/","page":"API","title":"API","text":"Pages = [\"function_index.md\"]","category":"page"},{"location":"api/function_index/#VIDA.VIDA","page":"API","title":"VIDA.VIDA","text":"VIDA\n\nIs a image feature extraction tool for use with EHT images of black holes. It assumes that the image is close to one of the templates we have implemented and then tries to extract that feature from the image using one of the probability divergences implemented.\n\n\n\n\n\n","category":"module"},{"location":"api/function_index/#VIDA.AbstractDivergence","page":"API","title":"VIDA.AbstractDivergence","text":"abstract type AbstractDivergence\n\nDefines an AbstractDivergence type. This is the basic cost function of VIDA.\n\nA subtype of AbstractDivergence must be a struct with at least two fields\n\nimg::IntensityMap which holds the image you wish to run feature extraction on\nmimg::IntensityMap which is an internal buffer that stores the model image.\n\nThe divergence is evaluated roughly as\n\n    normalize_div(div, sum(divergence_point(div, image, model)))\n\nTherefore a user must implement the following methods\n\ndivergence_point: Which evaluates the divergence at a single pixel\nnormalize_div: Which normalizes and modifies the\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.AbstractMovie","page":"API","title":"VIDA.AbstractMovie","text":"abstract type AbstractMovie\n\nCreates an abstract movie class\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.Bhattacharyya","page":"API","title":"VIDA.Bhattacharyya","text":"struct Bhattacharyya <: VIDA.AbstractDivergence\n\nType for the Bhattacharyya divergence. It constructed from an IntensityMap i.e. data. Additionally to evaluate the divergence we use a functor approach where if θ is your\n\nDetails\n\nThis computes the Bhattacharyya divergence which is related to Hellinger distance between two distributions. In fact, they are both minimized at the same point. The Bhattacharyya divergence is defined as\n\nBh(f_thetahatI) = -logint sqrtf_theta(xy)hatI(xy)dxdy\n\nwhere hatI is defined as the image normalized to unit flux.\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.KullbackLeibler","page":"API","title":"VIDA.KullbackLeibler","text":"struct KullbackLeibler <: VIDA.AbstractDivergence\n\nType for the KL divergence. It constructed from an IntensityMap i.e. data. Additionally to evaluate the divergence we use a functor approach where if θ is your\n\nDetails\n\nThis computes the KL divergence which is related to Hellinger distance between two distributions. In fact, they are both minimized at the same point. The Bhattacharyya divergence is defined as\n\nKL(f_thetahatI) = -logint f_theta(xy)log\n        left(fracf_theta(xy)hatI(xy)right)dxdy\n\nwhere hatI is defined as the image normalized to unit flux.\n\nThis struct is also a functor.\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.LeastSquares","page":"API","title":"VIDA.LeastSquares","text":"struct LeastSquares <: VIDA.AbstractDivergence\n\nType for the least squares divergence. It constructed from an IntensityMap i.e. data. Additionally to evaluate the divergence we use a functor approach where if θ is your\n\nDetails\n\nThis computes the squared 2 norm between your image and template, both of which are normalized to unit flux.\n\nTo construct this just pass it an image object\n\njulia> ls = LeastSquares(img::IntensityMap)\n\nNotes\n\nWe have a template internal matrix the prevents internal allocations during computation This is a internal feature that the user does not need to worry about.\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.NxCorr-Tuple{T} where T<:IntensityMap","page":"API","title":"VIDA.NxCorr","text":"NxCorr(img::IntensityMap)\n\nConstruct the normalized cross correlation (NXCORR) divergence with respect to the image img. To maximize the NXCorr we instead compute the -log(|NxCorr|) as the divergence\n\nNxCorr is defined as:     NXCORR(n, m) = (Nσₙσₘ) Σᵢ (nᵢ - μₙ)(mᵢ - μₘ) where n and m are the two images μ is the mean and σ is the pixelwise standard deviation\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.Renyi-Union{Tuple{T}, Tuple{T, Any}} where T<:IntensityMap","page":"API","title":"VIDA.Renyi","text":"Renyi(img::IntensityMap, α)\n\nConstruct the Renyi divergence with parameter α. It constructed from an IntensityMap i.e. data.\n\nDetails\n\nThis computes the KL divergence which is related to Hellinger distance between two distributions. In fact, they are both minimized at the same point. The Bhattacharyya divergence is defined as\n\nRy(f_thetahatI) = frac1α-1logint\n        left(fracf_theta(xy)^alphahatI(xy)^alpha-1right)dxdy\n\nwhere hatI is defined as the image normalized to unit flux.\n\nThis is a very flexible divergence that reduces to many of the other divergences implemented.\n\nα = 1 corresponds to the KL divergence\nα = 1/2 corresponds to the Bhattacharyya divergence up to a multiplicative factor of 2\n\nTypically we find that α=1.5 works well, as it focusses on the bright regions of the images moreso than the Bh and KL divergence. For α>2 the measure tends to devolve in something akin the to sup norm and fails to match the image structure.\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.VIDAMovie","page":"API","title":"VIDA.VIDAMovie","text":"struct VIDAMovie{T, F<:(IntensityMap{T, 3, D, G, A} where {D, G<:(ComradeBase.AbstractRectiGrid{D}), A<:AbstractArray{T, 3}}), I} <: VIDA.AbstractMovie\n\nDetails\n\nHolds a X,Y,T IntensityMap plus an interpolator that lets you make a continuous movie\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.VIDAMovie-Union{Tuple{IntensityMap{T, 3, D, G, A} where {D, G<:(ComradeBase.AbstractRectiGrid{D}), A<:AbstractArray{T, 3}}}, Tuple{T}} where T<:Real","page":"API","title":"VIDA.VIDAMovie","text":"VIDAMovie(mov::IntensityMap{T,3})\n\nCreate an VIDAMovie class for easy interpolation between frames.\n\nArguments\n\nmov: An IntensityMap with axes (:X, :Y, :Ti) that represent the frames of a movie.  Note that the time dimension does not have to be equi-spaced.\n\nReturns\n\nAn VIDAMovie object that behaves like IntensityMap but lets you interpolate between frames with get_image(vida_movie, time).\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.VIDAProblem","page":"API","title":"VIDA.VIDAProblem","text":"struct VIDAProblem{D<:VIDA.AbstractDivergence, F, N, B}\n\nA composite type that holds various properties that define the optimization process to extract the optimal filter.\n\nFields\n\ndiv: Divergence you will fit\n\nf: Function that defines the parametric family of templates\n\nautodiff: Type of autodiff to use when optimizing if any\n\nlb: The lower bounds of the parameter ranges to search over\n\nub: The upper bounds of parameter ranges to search over\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.VIDAProblem-NTuple{4, Any}","page":"API","title":"VIDA.VIDAProblem","text":"VIDAProblem(div, f, lb, ub)\n\n\nDefines a VIDAProblem for optimization.\n\nArguments\n\ndiv: The divergence you wish to fit. This is an instantiation of VIDA.AbstractDivergence\nf:   The function that defines the parametric family of templates you will fit. The function        must accept a named tuple as its first argument, whose names define the parameters.\nlb:  A NamedTuple whose names match the argument of f and whose values define the lower        bounds of the parameters range you want to search over\nlb: A NamedTuple whose names match the argument of f and whose values define the upper        bounds of the parameters range you want to search over\n\nExample\n\njulia> f(x) = SlashedGaussianRing(x.σ, x.s)\njulia> div = Renyi(img, 0.75)\njulia> lb = (x = 0.1, s = 0.001)\njulia> ub = (x = 10.0, s = 0.999)\njulia> prob = VIDAProblem(div, f, lb, ub)\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#ComradeBase.flux-Tuple{VIDAMovie, Any}","page":"API","title":"ComradeBase.flux","text":"flux(mov, t)\n\n\nReturns the flux of the mov at the times time in fractional hours\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.blur-Tuple{SpatialIntensityMap, Any}","page":"API","title":"VIDA.blur","text":"blur(img, fwhm)\n\n\nBlurs the img with a gaussian kernel with fwhm in μas. If fwhm is a scalar then the kernel is assumed to be symmetric, otherwise you the first entry is the fwhm in the EW direction and second the NS direction.\n\nReturns the blurred image.\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.blur-Tuple{VIDAMovie, Any}","page":"API","title":"VIDA.blur","text":"blur(mov, fwhm)\n\n\nBlurs the mov with a gaussian kernel with fwhm in μas. If fwhm is a scalar then the kernel is assumed to be symmetric, otherwise you the first entry is the fwhm in the EW direction and second the NS direction.\n\nReturns the blurred movie.\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.clipimage","page":"API","title":"VIDA.clipimage","text":"clipimage(clip, image)\nclipimage(clip, image, mode)\n\n\nClips the image im according to the value clip. There are two modes for image clipping:     - :relative which zeros the pixels whose intensity are below clip relative to the max.     - :absolute which zeros the pixels whose intensity is below clip in Jy/pixel\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VIDA.divergence-Tuple{VIDA.AbstractDivergence, ComradeBase.AbstractModel}","page":"API","title":"VIDA.divergence","text":"divergence(d, m)\n\n\nComputes the divergence of d with respect to the template m. This measure how similar the divergence with respect to the image stored in d is compared to the template.\n\nArguments\n\nd: An divergence or a subtype of VIDA.AbstractDivergence\nm: A template which ComradeBase.AbstractModel or more commonly      a VIDA.AbstractImageTemplate\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.divergence_point","page":"API","title":"VIDA.divergence_point","text":"divergence_point(div::AbstractDivergence, p, q)\n\nEvaluate the divergence div at a single pixel with value p and q for image and template. The total divergence\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VIDA.get_frames-Tuple{VIDAMovie}","page":"API","title":"VIDA.get_frames","text":"get_frames(mov)\n\n\nGets all the frames of the movie object mov. This returns a array of IntensityMap objects.\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.get_image-Tuple{VIDAMovie{var\"#s11\", F} where {var\"#s11\"<:Real, F<:(IntensityMap{var\"#s11\", 3, D, G, A} where {D, G<:(ComradeBase.AbstractRectiGrid{D}), A<:AbstractArray{var\"#s11\", 3}})}, Any}","page":"API","title":"VIDA.get_image","text":"get_image(mov, t; keeptime)\n\n\nGets the frame of the movie object mov at the time t. This returns an IntensityMap object at the requested time. The returned object is found by linear interpolation.\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.get_times-Tuple{VIDAMovie}","page":"API","title":"VIDA.get_times","text":"get_times(mov)\n\n\nReturns the times that the movie object mov was created at. This does not have to be uniform in time.\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.join_frames-Union{Tuple{T}, Tuple{Any, AbstractVector{T}}} where T<:(SpatialIntensityMap)","page":"API","title":"VIDA.join_frames","text":"join_frames(times, images)\n\n\nJoins an array of IntensityMap at specified times to form an VIDAMovie object.\n\nInputs\n\ntimes: An array of times that the image was created at\nimages: An array of IntensityMap objects\n\nOutputs\n\nVIDAMovie object\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.load_hdf5-Tuple{Any}","page":"API","title":"VIDA.load_hdf5","text":"load_hdf5(filename; polarization, style)\n\n\nLoads an hdf5 movie file where filename should be a HDF5 file.\n\nDetails\n\nThis reads in a hdf5 movie file and outputs and VIDAMovie object. If polarization=true we will read in all stokes parameters.\n\nNotes\n\nCurrently this only works with movies created by ehtim. \n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.load_im_h5-Tuple{String}","page":"API","title":"VIDA.load_im_h5","text":"load_im_h5(fname; polarization)\n\n\nwhere fname should be a hdf5 image file generated using illinois hdf5 process\n\nDetails\n\nThe function returns an IntensityMap object that contains the relevant image and parameters extracted from the fits file. It also ensures that we are astronomers and that the image using sky-left coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.load_image-Tuple{Any}","page":"API","title":"VIDA.load_image","text":"load_image(fname; polarization)\n\n\nwhere fname is a image file. This will call a method based on the file extension. Curerntly we have .fits, and .h5 implemented.\n\nDetails\n\nThis reads in a fits file that is more robust to the various imaging algorithms in the EHT, i.e. is works with clean, smili, eht-imaging.\n\nThe function returns an IntensityMap object that contains the relevant image and parameters extracted from the fits file. It also ensures that we are astronomers and that the image using sky-left coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.normalize_div","page":"API","title":"VIDA.normalize_div","text":"normalize_div(div, val)\n\nReturns the proper divergence whose values have been normalized so that the value is always postive semi-definite and is only zero then the template and the image are equal.\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VIDA.nxcorr-Union{Tuple{T}, Tuple{IntensityMap{T, N, D, G, A} where {N, D, G<:(ComradeBase.AbstractRectiGrid{D}), A<:AbstractArray{T, N}}, IntensityMap{T, N, D, G, A} where {N, D, G<:(ComradeBase.AbstractRectiGrid{D}), A<:AbstractArray{T, N}}}} where T<:Real","page":"API","title":"VIDA.nxcorr","text":"nxcorr(img1, img2)\n\n\nReturns the normalized cross correlation (NXCORR) between img1 and img2. NXCORR is defined as\n\nNXCORR(n, m) = (Nσₙσₘ) Σᵢ (nᵢ - μₙ)(mᵢ - μₘ)\n\nwhere n and m are the two images μ is the mean and σ is the pixelwise standard deviation\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.save_hdf5-Tuple{Any, Any}","page":"API","title":"VIDA.save_hdf5","text":"save_hdf5(filename, mov; style)\n\n\nSaves and hdf5 file where filename is the write out location. Currently style only works with ehtim, namely we save HDF5 files that only work with ehtim.\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.triptic","page":"API","title":"VIDA.triptic","text":"triptic(img::SpatialIntensityMap, template)\n\nPlots a triptic where the left panel is the img middle the template and the right a two cross-sections of the image and template\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VIDA.vida","page":"API","title":"VIDA.vida","text":"Runs the VIDA algorithm to find the optimal template defined by the problem prob. The optimization will be run using the Optimization.jl optimizer. You can optionally pass a random number generator used to specify the initial points or can explicitly pass the initial location of the optimization using init_params. By default vida first transforms the parameter space to the unit hypercube. If you do not wish to do this set unit_cube = false.\n\nThe remaining kwargs... are forwarded to the Optimization.solve function.\n\nwarn: Warn\nTo use this function a user must first load Optimization, i.e. using Optimization\n\nArguments\n\nprob: Defines the problem you wish to solve.\noptimizer: Specifies the optimizer you want to use. Any optimizer from Optimization.jl works.\n\nOptional Keyword arguments\n\nrng: Specifies the random number generator you want to use to select the initial points.        Note that is not forwarded to the optimizers since not all can use a specific rng.\ninit_params: Specify the initial point of the optimization routine. The default nothing                will randomly draw a starting point from the parameter space\nunit_cube: If true the parameters are first transformed to the unit hypercube. If false              they are transformed to ℝⁿ using TransformVariables\nkwargs...: Additional options to be passed to the solve function from Optimization.jl\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VLBISkyModels.regrid-Tuple{VIDAMovie, RectiGrid{<:Tuple{var\"#s72\", var\"#s71\"} where {var\"#s72\"<:X, var\"#s71\"<:Y}}}","page":"API","title":"VLBISkyModels.regrid","text":"regrid(mov::VIDAMovie, npix, xlim, ylim)\n\nInputs\n\nmov::VIDAMovie : Movie you want to regrid\nnpix : Number of pixels in x and y direction\nxlim : Tuple with the limits of the image in the RA\nylim : Tuple with the limits of the image in DEC\n\n\n\n\n\n","category":"method"},{"location":"interface/#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"interface/#Templates","page":"Interfaces","title":"Templates","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"The template describe the image features we wish to extract.  As of 0.11 VIDA uses the ComradeBase.jl  and VLBISkyModels.jl interface. This means that any model that obeys that interface can be used within VIDA. Additionally VIDA defines a number of additional templates that are useful. For a complete list see the API page.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"For specifically VIDA you should subtype VLBISkyModels.AbstractImageTemplate subtype of the ComradeBase.AbstractModel type and partially implemented some functions. For instance, we assume that ComradeBase.imanalytic(::Type{<:AbstractImageTemplate}) = IsAnalytic(). As such if an end user wants to implement a new feature they just need to implement","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"ComradeBase.intensity_point(m::MyNewTemplate, p)\nComradeBase.radialextent(m::MyNewTemplate)","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Note we do not implement the flux of the templates since they are often difficult to calculate.","category":"page"},{"location":"interface/#Divergence-AbstractDivergence","page":"Interfaces","title":"Divergence AbstractDivergence","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"In order to extract a feature you need to create a probability divergence function. Currently the divergences are defined using  a VIDA.AbstractDivergence type. The general user-facing interface is","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"bh = Bhattacharyya(image) #make the Bh divergence\nkl = KullbackLeibler(image) #makes the KL divergence","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"to initialize the divergence. To evaluate the divergence on a template you use the VIDA.divergence function","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"divergence(bh, θ::AbstractTemplate)\ndivergence(kl, θ::AbstractTemplate)","category":"page"},{"location":"interface/#Extract-features-vida-and-VIDAProblem","page":"Interfaces","title":"Extract features vida and VIDAProblem","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"The main goal of VIDA is to extract image features. To do this we need to define the template and parameterization we want to use.  The first step is to create a template function that takes in a NamedTuple and returns an <:ComradeBase.AbstractModel. For example","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"temp(θ) = GaussianRing(θ.r0, θ.σ, θ.x0, θ.y0)","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"For our search we also need to provide the domain over which we want to search","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"lower = (r0 = 5.0, σ = 0.1, x0 = -60.0, y0 = 60.0)\nupper = (r0 = 30.0, σ = 5.0, x0 = -60.0, y0 = 60.0)","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"We can then form our VIDA.VIDAProblem using the divergence defined above","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"prob = VIDAProblem(bh, temp, lower, upper)","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Finally, to get the optimal parameters and template we can call the VIDA.vida function","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"using OptimizationMetaheuristics\nxopt, opt_template, divmin = vida(prob, ECA())","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"warning: Warning\nOlder versions of VIDA also included a threaded version of vida. This no longer exists and would give a race condition if someone tried to use it at this point due to a difference in how divergence is calculated. If you want to run multiple copies of VIDA at once please use Julia's Distributed functionality.","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#A-minimal-example-of-extracting-ring-features","page":"Getting Started","title":"A minimal example of extracting ring features","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The basic VIDA program mirrors the following structure","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using VIDA, CairoMakie\n# load the image and plot it\nimage = load_fits(\"example/data/elliptical_gaussian_rot-0.00.fits\")\nimageviz(image)\n# Build the divergence we want to fit\nbh = Bhattacharyya(image)\n# Create the template to use\ntemplate(θ) = SlashedGaussianRing(θ.r0, θ.σ, θ.s, θ.ξ, θ.x0, θ.y0) + θ.floor*Constant(μas2rad(100.0))\n\n#Define our bounds\nlower = (r0 = μas2rad(5.0), σ=μas2rad(1.0), \n         s=0.001, ξ=-1π, \n         x0=-μas2rad(60.0), y0 = -μas2rad(60.0), \n         floor=1e-6)\nupper = (r0 = μas2rad(30.0), σ=μas2rad(15.0), \n         s=0.999, ξ=1π, \n         x0=μas2rad(60.0), y0 = μas2rad(60.0), \n         floor=100.0)\n\nprob = VIDAProblem(bh, template, lower, upper)\n# Load your optimizer and run VIDA\nusing OptimizationBBO\nxopt, opt_temp, divmin = vida(prob, BBO_adaptive_de_rand_1_bin(); maxiters=50_000)\n\n#plot the results\nfig = triptic(image, opt_temp)\nfig","category":"page"},{"location":"getting_started/#Idea-behind-VIDA","page":"Getting Started","title":"Idea behind VIDA","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"VIDA is based on the idea of interpreting the image as a probability distribution. Namely since any image is integrable, the space of images is in one-to-one correspondence with a probability distribution.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Therefore, our idea is very close to variational inference, hence the name (the) Variational Image Domain Analysis. Namely, where we view the image as a distribution and we aim to find a approximation of the distribution given some parametric family f_theta(xy), which for our purposes we will typically call a template.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The choice of template, depends on the problem of interest, namely what features we are interested in. Typically for the Event Horizon Telescope (EHT) where the images tend to be rings, we are interested in","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Radius r₀\nWidth or half width σ\nStructural asymmetry τ\nBrightness asymmetry s\nPosition angle ξ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"VIDA then defines a series of templates parameterize these features.","category":"page"},{"location":"getting_started/#Templates","page":"Getting Started","title":"Templates","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Currently we have 6 templates defined, although they all belong to the same family. For an example on how to see the process for defining your own template please see the Adding a Custom Template.","category":"page"},{"location":"getting_started/#Divergences","page":"Getting Started","title":"Divergences","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In order to extract features we first need a cost function that penalized our parameterized distributions f_theta(xy). Since we are considering the image as a probability distribution, one cost function would be the distance or divergence between two distributions. A probability divergence is just a functional that takes in two probability distributions p,q and is minimized iff pequiv q.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Divergences are defined by the abstract type VIDA.AbstractDivergence. Implementations of the this type are also expected to implement a functor that evaluates the divergence on some template.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The current recommended default template is the VIDA.Bhattacharyya divergence although all the template give similar answers.","category":"page"},{"location":"generated/custom_template/#Adding-a-Custom-Template","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"","category":"section"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"If you want to add your own template you just need to define a new:","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"subtype of VIDA.AbstractImageTemplate\nimplement the interface desribed in VIDA.AbstractImageTemplate","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"In this tutorial we will implement a custom template from scratch.","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"using VIDA\n\nusing Pkg #hide\nPkg.activate(joinpath(dirname(pathof(VIDA)), \"..\", \"example\")) #hide\n\n\nstruct SlashedExponentialRing{T} <: VLBISkyModels.AbstractImageTemplate\n    αouter::T\n    αinner::T #standard deviation of the Gaussian\n    s::T\nend\n\nfunction VIDA.intensity_point(m::SlashedExponentialRing, p)\n    (; X, Y) = p\n    (; αinner, αouter, s) = m\n    r = hypot(X, Y)\n    ϕ = atan(X, -Y)\n\n    n = (1 - s * cos(ϕ))\n\n    return n * r^αinner / (1 + r^(αouter + αinner + 1))\nend","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"We can also add a convienence constructor","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"function SlashedExponentialRing(r0, αouter, αinner, s, ξs, x0, y0)\n    return modify(\n        SlashedExponentialRing(αouter, αinner, s),\n        Stretch(r0, r0), Rotate(ξs), Shift(x0, y0)\n    )\nend","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"Then you can simply call the same optimizing functions and plotting functions. For example lets create a fake image and fit it","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"template = SlashedExponentialRing(μas2rad(20.0), 3.0, 4.0, 0.5, π / 2, 0.0, 0.0)","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"VIDA uses ComradeBase and VLBISkyModels interface. Therefore, we can create an image using intensitymap","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"g = imagepixels(μas2rad(128.0), μas2rad(128.0), 64, 64)\nimg = intensitymap(template, g)","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"We can also plot the image","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"using CairoMakie\nimageviz(img)","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"Now lets see if we can get the correct parameters. First we construct our optimization divergence the Bhattacharyya divergence.","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"bh = Bhattacharyya(img);\nnothing #hide","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"To fit we need to define a fitting function. For this our template function needs to accept a named tuple.","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"temp(θ) = SlashedExponentialRing(θ.r0, θ.αout, θ.αin, θ.s, θ.ξs, θ.x0, θ.y0)","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"Additionally we need to define the search region for our template extraction","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"upper = (r0 = μas2rad(40.0), αout = 10.0, αin = 10.0, s = 0.999, ξs = 1π, x0 = μas2rad(60.0), y0 = μas2rad(60.0))\nlower = (r0 = μas2rad(5.0), αout = 1.0, αin = 0.0, s = 0.001, ξs = -1π, x0 = -μas2rad(60.0), y0 = -μas2rad(60.0))","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"We can now create our problem","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"prob = VIDAProblem(bh, temp, lower, upper)","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"The vida method can use any optimizer that works with Optimization.jl For this work we will use BlackBoxOptim.jl.","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"using OptimizationBBO\nxopt, θopt, divmin = vida(prob, BBO_adaptive_de_rand_1_bin(); maxiters = 50_000)\n\n@show θopt","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"Let's also plot the results","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"fig = triptic(img, θopt)\nfig","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"Now with all of this said this template actually already exists in VIDA using the flexible VIDA.RingTemplate.","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"rad = RadialDblPower(xopt.αin, xopt.αout)\nazi = AzimuthalCosine(xopt.s, xopt.ξs)\nt = modify(RingTemplate(rad, azi), Stretch(xopt.r0), Shift(xopt.x0, xopt.y0))","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"fig = triptic(img, t);\nfig","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/introduction/#Introduction-to-VIDA","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"","category":"section"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Using VIDA is based on constructing three items:","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Data, i.e. an image that you want to extract features from.\nCost function, i.e. pick if you want to use the KL or BH divergence\nTemplate, i.e. construct the family of distributions or templates that you will use to approximate the image.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Then all you need to do is minimize the divergence and you will have extracted you image features.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Now lets runs through how that works","category":"page"},{"location":"generated/introduction/#Getting-started","page":"Introduction to VIDA","title":"Getting started","text":"","category":"section"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To load VIDA we follow the typical Julia flow. Note that to include plotting functionality you need to include Plots as well","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"using VIDA\n\nusing Pkg #hide\nPkg.activate(joinpath(dirname(pathof(VIDA)), \"..\", \"example\")) #hide\n\n\nusing CairoMakie\nusing InteractiveUtils","category":"page"},{"location":"generated/introduction/#Step-1-Read-in-Data","page":"Introduction to VIDA","title":"Step 1 Read in Data","text":"","category":"section"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"VIDA currently only works with fits images. The fits header is based off of what eht-imaging outputs. So as long as you stick to that standard you should be fine.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To read in an image we just use the VIDA.load_image function which should work with any fits image from ehtim and clean","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"img = load_image(joinpath(dirname(pathof(VIDA)), \"../example/data/example_image.fits\"));\nnothing #hide","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To see what this img is lets print the type","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"println(typeof(img))","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To plot the image we use the VLBISkyModels.imageviz function.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"imageviz(img)","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"So from the output we see that img is a IntensityMap type. This follows ComradeBase and VLBISkyModels, see their docs for more information.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Julia isn't a traditional class OOP language. Namely, methods/functions are first class and aren't members of a class. Instead how a function behaves is dependent on the type of argument inputs. This is known as something called multimethods or multiple dispatch where at run-time the type of functions called is determined by the arguments.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"In some sense OOP is just a multiple dispatch type language where the our type of dispatch only depends on the class, i.e. the self argument in Python classes.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Now because of the lack of classes sometimes it can be difficult to figure out which functions will act of our datatypes, e.g. the IntensityMap type. Fortunately, Julia has some convenience functions that let you see which functions/methods can act of the IntensityMap type","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"methodswith(IntensityMap)\n\n\n# Creating a divergence","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"In order to find the optimal template you need to first decide on your objective or cost function. In VIDA we use probaility divergences to measure differences between the template and image. A divergence is defined as an abstract type VIDA.AbstractDivergence.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"bh = Bhattacharyya(img);\nkl = KullbackLeibler(img);\nnothing #hide","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Now to evaluate the divergence we need a template to compare the image to. For instance lets create a few different templates","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"gr = GaussianRing(μas2rad(20.0), μas2rad(5.0), 0.0, 0.0)\nggr = EllipticalSlashedGaussianRing(\n    μas2rad(20.0), # r0\n    μas2rad(5.0), # σ\n    0.2, # τ\n    0.78, # ξτ\n    0.5, # s\n    0.78, # ξs\n    μas2rad(-10.0), # x0\n    0.0 # y0\n)","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"We can also plot both templates","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"g = imagepixels(μas2rad(128.0), μas2rad(128.0), 128, 128)\nfig = Figure(; size = (600, 300))\naxis = axis = (aspect = 1, xticklabelsvisible = false, yticklabelsvisible = false)\nimage(fig[1, 1], intensitymap(gr, g), colormap = :afmhot, axis = merge(axis, (title = \"GaussianRing\",)))\nimage(fig[1, 2], intensitymap(ggr, g), colormap = :afmhot, axis = merge(axis, (title = \"GeneralGaussianRing\",)))\nfig","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"VIDA has a number of templates defined. These are all subtypes of the AbstractTemplate type. To see which templates are implemented you can use the subtype method:","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"subtypes(VLBISkyModels.AbstractImageTemplate)","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Additionally as of VIDA 0.11 we can also use any VLBISkyModels model and any model that satisfies the interface described here.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Using VLBISkyModels interface we can also combine templates together","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"add = gr + 2.0 * shifted(gr, μas2rad(-10.0), μas2rad(10.0))","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To evaluate the divergence between our template and image we then just evaluate the VIDA.divergence on the template","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"@show divergence(kl, add);\n@show divergence(kl, ggr);\n@show divergence(kl, add);\nnothing #hide","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Now neither template is really a great approximation to the true image. For instance visually they look quite different, which can be checked with the VIDA.triptic function","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"figa, ax = triptic(img, gr)\nfiga","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"figb, ax = triptic(img, ggr)\nfigb","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"figc, ax = triptic(img, add)\nfigc","category":"page"},{"location":"generated/introduction/#Extracting-the-Optimal-Template","page":"Introduction to VIDA","title":"Extracting the Optimal Template","text":"","category":"section"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To extract the optimal template the first thing you need to do is define your a function that construct the template and parameterization you will consider","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"function gr_temp(θ)\n    return GaussianRing(θ.r0, θ.σ, θ.x0, θ.y0)\nend","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"We also want to select the domain that we want to search over","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"lower = map(μas2rad, (r0 = 5.0, σ = 0.01, x0 = -60.0, y0 = -60.0))\nupper = map(μas2rad, (r0 = 60.0, σ = 20.0, x0 = 60.0, y0 = 60.0))","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Given that we can form the VIDA.VIDAProblem type.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"prob = VIDAProblem(bh, gr_temp, lower, upper);\nnothing #hide","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Now we need to optimize. VIDA uses the Optimization.jl meta package for optimization. That means that we can use any optimization package that works with optimization. For information about possible optimizers see their docs.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"For VIDA the classic optimizer is using the BlackBoxOptim.jl. To use BlackBox optim we need to load the required package","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"using OptimizationBBO","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"However, for this tutorial we will use the BlackBoxOptim optimizer.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To optimize all you need to do is run the VIDA.vida function.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"xopt, optfilt, divmin = vida(prob, BBO_de_rand_1_bin_radiuslimited(); maxiters = 100_000)\nfig, ax = triptic(img, optfilt)\nfig","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Well that seemed to do a terrible job. The reason is that a lot of these images tend to have some low level flux throughout the image. To account for this the template tends to get very big to absorb some of this flux. To combat this you can add a constant background template to the problem.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"gr_temp_cont(θ) = GaussianRing(θ.r0, θ.σ, θ.x0, θ.y0) + θ.f * VLBISkyModels.Constant((μas2rad(100.0)))\nlower = (r0 = μas2rad(5.0), σ = μas2rad(0.01), x0 = μas2rad(-60.0), y0 = μas2rad(-60.0), f = 1.0e-6)\nupper = (r0 = μas2rad(60.0), σ = μas2rad(20.0), x0 = μas2rad(60.0), y0 = μas2rad(60.0), f = 10.0)\nprob = VIDAProblem(bh, gr_temp_cont, lower, upper);\nxopt, optfilt, divmin = vida(prob, BBO_de_rand_1_bin_radiuslimited(); maxiters = 50_000)","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"fig, ax = triptic(img, optfilt)\nfig","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"That's much better! Now if you wanted to capture the asymmetry in the ring you can use other templates, for example the CosineRing template. Note that this template tends to be a little harder to fit.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"cos_temp(θ) = EllipticalSlashedGaussianRing(θ.r0, θ.σ, θ.τ, θ.ξτ, θ.s, θ.ξs, θ.x0, θ.y0) + θ.f * θ.f * VLBISkyModels.Constant(μas2rad(100.0))\nlower = (r0 = μas2rad(1.0), σ = μas2rad(0.01), τ = 0.0, ξτ = -π / 2, s = 0.001, ξs = -1π, x0 = μas2rad(-60.0), y0 = μas2rad(-60.0), f = 1.0e-6)\nupper = (r0 = μas2rad(60.0), σ = μas2rad(20.0), τ = 0.5, ξτ = π / 2, s = 0.999, ξs = 1π, x0 = μas2rad(60.0), y0 = μas2rad(60.0), f = 10.0)\nprob = VIDAProblem(bh, cos_temp, lower, upper);\nxopt, optfilt, divmin = vida(prob, BBO_de_rand_1_bin_radiuslimited(); maxiters = 50_000);\nnothing #hide","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"fig, ax = triptic(img, optfilt)\nfig","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Now looks pretty great! To see how to add a custom template see the Adding a Custom Template page.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#VIDA.jl","page":"Home","title":"VIDA.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Variational image domain analysis for the EHT. This package is for extracting features, such as ring from image reconstruction of EHT data. Currently these images must be in fits format although other types may be included in the future.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"VIDA is a registered Julia package to install","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(\"VIDA\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or go to the repl and simply type ]add VIDA. Note that we require a Julia version >= 1.4.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some additional dependencies that enable full functionality can be added with","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.add.([\"Plots\",\"ArgParse\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Plots.jl is required to use some of the plotting recipes defined in the package and ArgParse is used for some of the scripts in the example folder.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To extract features we use probability divergences to characterize differences between our image and some approximation. For the divergences implemented see the Getting Started page. The idea is then very similar to variational inferences where we pick a parametric family of distributions which we call templates and then try to find the template that minimizes the divergence. For the templates that are currently implemented please see the page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the API for the complete list of documented functions and types.","category":"page"},{"location":"#Outline","page":"Home","title":"Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"index.md\",\n  \"getting_started.md\",\n  \"interface.md\",\n  \"generated/introduction.md\",\n  \"generated/custom_template.md\",\n  \"api/function_index.md\"\n]","category":"page"}]
}
