<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · VIDA.jl</title><meta name="title" content="API · VIDA.jl"/><meta property="og:title" content="API · VIDA.jl"/><meta property="twitter:title" content="API · VIDA.jl"/><meta name="description" content="Documentation for VIDA.jl."/><meta property="og:description" content="Documentation for VIDA.jl."/><meta property="twitter:description" content="Documentation for VIDA.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">VIDA.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../interface/">Interfaces</a></li><li><a class="tocitem" href="../../generated/introduction/">Introduction to VIDA</a></li><li><a class="tocitem" href="../../generated/custom_template/">Adding a Custom Template</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ptiede/VIDA.jl/blob/master/docs/src/api/function_index.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#API">API</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#VIDA.VIDA"><code>VIDA.VIDA</code></a></li><li><a href="#VIDA.AbstractDivergence"><code>VIDA.AbstractDivergence</code></a></li><li><a href="#VIDA.AbstractImageTemplate"><code>VIDA.AbstractImageTemplate</code></a></li><li><a href="#VIDA.AbstractMovie"><code>VIDA.AbstractMovie</code></a></li><li><a href="#VIDA.AzimuthalCosine"><code>VIDA.AzimuthalCosine</code></a></li><li><a href="#VIDA.AzimuthalUniform-Tuple{}"><code>VIDA.AzimuthalUniform</code></a></li><li><a href="#VIDA.Bhattacharyya"><code>VIDA.Bhattacharyya</code></a></li><li><a href="#VIDA.Constant"><code>VIDA.Constant</code></a></li><li><a href="#VIDA.CosineRing"><code>VIDA.CosineRing</code></a></li><li><a href="#VIDA.GaussDisk-NTuple{4, Any}"><code>VIDA.GaussDisk</code></a></li><li><a href="#VIDA.GaussDisk"><code>VIDA.GaussDisk</code></a></li><li><a href="#VIDA.KullbackLeibler"><code>VIDA.KullbackLeibler</code></a></li><li><a href="#VIDA.LeastSquares"><code>VIDA.LeastSquares</code></a></li><li><a href="#VIDA.LogSpiral-NTuple{7, Any}"><code>VIDA.LogSpiral</code></a></li><li><a href="#VIDA.LogSpiral"><code>VIDA.LogSpiral</code></a></li><li><a href="#VIDA.NxCorr-Tuple{T} where T&lt;:IntensityMap"><code>VIDA.NxCorr</code></a></li><li><a href="#VIDA.RadialDblPower"><code>VIDA.RadialDblPower</code></a></li><li><a href="#VIDA.RadialGaussian"><code>VIDA.RadialGaussian</code></a></li><li><a href="#VIDA.RadialTruncExp"><code>VIDA.RadialTruncExp</code></a></li><li><a href="#VIDA.Renyi-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:IntensityMap"><code>VIDA.Renyi</code></a></li><li><a href="#VIDA.RingTemplate"><code>VIDA.RingTemplate</code></a></li><li><a href="#VIDA.VIDAMovie-Union{Tuple{IntensityMap{T, 3, D, A} where {D, A&lt;:AbstractArray{T, 3}}}, Tuple{T}} where T&lt;:Real"><code>VIDA.VIDAMovie</code></a></li><li><a href="#VIDA.VIDAMovie"><code>VIDA.VIDAMovie</code></a></li><li><a href="#VIDA.VIDAProblem-NTuple{4, Any}"><code>VIDA.VIDAProblem</code></a></li><li><a href="#VIDA.VIDAProblem"><code>VIDA.VIDAProblem</code></a></li><li><a href="#ComradeBase.flux-Tuple{Any, Any}"><code>ComradeBase.flux</code></a></li><li><a href="#VIDA.CosineRingwFloor-Union{Tuple{M}, Tuple{N}, Tuple{Any, Any, Tuple{Vararg{T, N}} where T, Tuple{Vararg{T, N}} where T, Tuple{Vararg{T, M}} where T, Tuple{Vararg{T, M}} where T, Any, Any, Any}} where {N, M}"><code>VIDA.CosineRingwFloor</code></a></li><li><a href="#VIDA.CosineRingwGFloor-Union{Tuple{M}, Tuple{N}, Tuple{Any, Any, Tuple{Vararg{T, N}} where T, Tuple{Vararg{T, N}} where T, Tuple{Vararg{T, M}} where T, Tuple{Vararg{T, M}} where T, Vararg{Any, 4}}} where {N, M}"><code>VIDA.CosineRingwGFloor</code></a></li><li><a href="#VIDA.EllipticalCosineRing-Union{Tuple{M}, Tuple{N}, Tuple{Any, Any, Tuple{Vararg{T, N}} where T, Tuple{Vararg{T, N}} where T, Any, Any, Tuple{Vararg{T, M}} where T, Tuple{Vararg{T, M}} where T, Any, Any}} where {N, M}"><code>VIDA.EllipticalCosineRing</code></a></li><li><a href="#VIDA.EllipticalGaussianRing-NTuple{6, Any}"><code>VIDA.EllipticalGaussianRing</code></a></li><li><a href="#VIDA.EllipticalSlashedGaussianRing-NTuple{8, Any}"><code>VIDA.EllipticalSlashedGaussianRing</code></a></li><li><a href="#VIDA.GaussianRing-Tuple{Any}"><code>VIDA.GaussianRing</code></a></li><li><a href="#VIDA.GaussianRing-NTuple{4, Any}"><code>VIDA.GaussianRing</code></a></li><li><a href="#VIDA.SlashedGaussianRing-Tuple{Any, Any}"><code>VIDA.SlashedGaussianRing</code></a></li><li><a href="#VIDA.SlashedGaussianRing-NTuple{6, Any}"><code>VIDA.SlashedGaussianRing</code></a></li><li><a href="#VIDA.blur-Tuple{VIDAMovie, Any}"><code>VIDA.blur</code></a></li><li><a href="#VIDA.blur-Tuple{SpatialIntensityMap, Any}"><code>VIDA.blur</code></a></li><li><a href="#VIDA.clipimage"><code>VIDA.clipimage</code></a></li><li><a href="#VIDA.divergence-Tuple{VIDA.AbstractDivergence, ComradeBase.AbstractModel}"><code>VIDA.divergence</code></a></li><li><a href="#VIDA.divergence_point"><code>VIDA.divergence_point</code></a></li><li><a href="#VIDA.get_frames-Tuple{VIDAMovie}"><code>VIDA.get_frames</code></a></li><li><a href="#VIDA.get_image-Tuple{VIDAMovie, Any}"><code>VIDA.get_image</code></a></li><li><a href="#VIDA.get_times-Tuple{VIDAMovie}"><code>VIDA.get_times</code></a></li><li><a href="#VIDA.join_frames-Union{Tuple{T}, Tuple{Any, Vector{T}}} where T&lt;:(SpatialIntensityMap)"><code>VIDA.join_frames</code></a></li><li><a href="#VIDA.load_hdf5-Tuple{Any}"><code>VIDA.load_hdf5</code></a></li><li><a href="#VIDA.load_im_h5-Tuple{String}"><code>VIDA.load_im_h5</code></a></li><li><a href="#VIDA.load_image-Tuple{Any}"><code>VIDA.load_image</code></a></li><li><a href="#VIDA.normalize_div"><code>VIDA.normalize_div</code></a></li><li><a href="#VIDA.nxcorr-Union{Tuple{T}, Tuple{IntensityMap{T, N, D, A} where {N, D, A&lt;:AbstractArray{T, N}}, IntensityMap{T, N, D, A} where {N, D, A&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><code>VIDA.nxcorr</code></a></li><li><a href="#VIDA.save_hdf5-Tuple{Any, Any}"><code>VIDA.save_hdf5</code></a></li><li><a href="#VIDA.triptic"><code>VIDA.triptic</code></a></li><li><a href="#VIDA.vida-Tuple{VIDAProblem, Any}"><code>VIDA.vida</code></a></li><li><a href="#VLBISkyModels.regrid-Tuple{VIDAMovie, RectiGrid{&lt;:Tuple{var&quot;#s51&quot;, var&quot;#s50&quot;} where {var&quot;#s51&quot;&lt;:X, var&quot;#s50&quot;&lt;:Y}}}"><code>VLBISkyModels.regrid</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.VIDA" href="#VIDA.VIDA"><code>VIDA.VIDA</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">VIDA</code></pre><p>Is a image feature extraction tool for use with EHT images of black holes. It assumes that the image is close to one of the templates we have implemented and then tries to extract that feature from the image using one of the probability divergences implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/VIDA.jl#LL2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.AbstractDivergence" href="#VIDA.AbstractDivergence"><code>VIDA.AbstractDivergence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractDivergence</code></pre><p>Defines an <code>AbstractDivergence</code> type. This is the basic cost function of <code>VIDA</code>.</p><p>A subtype of <code>AbstractDivergence</code> must be a <code>struct</code> with at least two fields</p><ul><li><code>img::IntensityMap</code> which holds the image you wish to run feature extraction on</li><li><code>mimg::IntensityMap</code> which is an internal buffer that stores the model image.</li></ul><p>The divergence is evaluated roughly as</p><pre><code class="language-julia hljs">    normalize_div(div, sum(divergence_point(div, image, model)))</code></pre><p>Therefore a user must implement the following methods</p><ul><li><a href="#VIDA.divergence_point"><code>divergence_point</code></a>: Which evaluates the divergence at a single pixel</li><li><a href="#VIDA.normalize_div"><code>normalize_div</code></a>: Which normalizes and modifies the</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/divergences.jl#LL3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.AbstractImageTemplate" href="#VIDA.AbstractImageTemplate"><code>VIDA.AbstractImageTemplate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractImageTemplate &lt;: ComradeBase.AbstractModel</code></pre><p>An abstract <code>ComradeBase.AbstractModel</code> that serves as the parent type of all the <code>VIDA</code> templates implemented in this repo.</p><p>By default this model assumes the following <code>ComradeBase</code> traits</p><pre><code class="language-julia hljs">ComradeBase.visanalytic(::Type{&lt;:AbstractImageTemplate}) = NoAnalytic()
ComradeBase.imanalytic(::Type{&lt;:AbstractImageTemplate})  = IsAnalytic()
ComradeBase.ispolarized(::Type{&lt;:AbstractImageTemplate}) = NotPolarized()</code></pre><p>As a result if a user wishes the implement their own subtype (e.g., <code>MyTemplate</code>) of <code>AbstratImageTemplate</code> they will need to implement the following methods</p><ul><li><code>ComradeBase.intensity_point(m::MyTemplate, p)</code>: which computes the potentially unormalized brightness of the template at the point <code>p</code>.</li><li><code>ComradeBase.radialextent(m::MyTemplate)</code>: which computes the rough radial extent of the model <code>m</code>.</li></ul><p>For more information about the total interface see <a href="https://ehtjulia.github.io/VLBISkyModels.jl/stable/interface/">VLBISkyModels.jl</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/templates.jl#LL1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.AbstractMovie" href="#VIDA.AbstractMovie"><code>VIDA.AbstractMovie</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractMovie</code></pre><p>Creates an abstract movie class</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/movies.jl#LL1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.AzimuthalCosine" href="#VIDA.AzimuthalCosine"><code>VIDA.AzimuthalCosine</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AzimuthalCosine(s::NTuple{N,T}, ξ::NTuple{N, T}) where {N, T}</code></pre><p>A azimuthal profile that is  given by a cosine expansion of order <code>N</code>. The expansion is given by</p><pre><code class="nohighlight hljs">    1 - ∑ₙ sₙcos(nϕ - ξₙ)</code></pre><p><strong>Notes</strong></p><p>This is usually couple with a radial profile to create a general ring template</p><pre><code class="language-julia-repl hljs">julia&gt; rad = RadialDblPower(3.0, 3.0)
julia&gt; azi = AzimuthalCosine((0.5, 0.2), (0.0, π/4)) # Defaults to Float64
julia&gt; t = RingTemplate(rad, azi)</code></pre><p><strong>Arguments</strong></p><ul><li><code>s</code> : amplitudes of the <code>N</code> order cosine expansion of the azimuthal brightness</li><li><code>ξs</code>: phase of the <code>N</code> order cosine expansion of the azimuthal brightness</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/rings.jl#LL184-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.AzimuthalUniform-Tuple{}" href="#VIDA.AzimuthalUniform-Tuple{}"><code>VIDA.AzimuthalUniform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AzimuthalUniform()
AzimuthalUniform{T}()</code></pre><p>A azimuthal profile that is uniform for all angles.</p><p><strong>Notes</strong></p><p>This is usually couple with a radial profile to create a general ring template</p><pre><code class="language-julia-repl hljs">julia&gt; rad = RadialDblPower(3.0, 3.0)
julia&gt; azi = AzimuthalUniform() # Defaults to Float64
julia&gt; t = RingTemplate(rad, azi)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/rings.jl#LL164-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.Bhattacharyya" href="#VIDA.Bhattacharyya"><code>VIDA.Bhattacharyya</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Bhattacharyya{T&lt;:IntensityMap} &lt;: VIDA.AbstractDivergence</code></pre><p>Type for the Bhattacharyya divergence. It constructed from an <code>IntensityMap</code> i.e. data. Additionally to evaluate the divergence we use a functor approach where if θ is your</p><p><strong>Details</strong></p><p>This computes the Bhattacharyya divergence which is related to Hellinger distance between two distributions. In fact, they are both minimized at the same point. The Bhattacharyya divergence is defined as</p><p class="math-container">\[Bh(f_\theta||\hat{I}) = -\log\int \sqrt{f_\theta(x,y)\hat{I}(x,y)}dxdy,\]</p><p>where <span>$\hat{I}$</span> is defined as the image normalized to unit flux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/divergences.jl#LL106-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.Constant" href="#VIDA.Constant"><code>VIDA.Constant</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Constant{T} &lt;: VIDA.AbstractImageTemplate</code></pre><p>An constant template.</p><p><strong>Details</strong></p><p>Defines an image that just has constant flux. This is very useful for soaking up low levels of flux in image reconstructions that can bias the results.</p><p>Since images or normalized to unity, this means the <code>Constant</code> template has no additional parameters.</p><p><strong>Fields</strong></p><ul><li><code>scale</code>: Sets the angular scale of the image. This is usually equal to the image FOV</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/image.jl#LL78-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.CosineRing" href="#VIDA.CosineRing"><code>VIDA.CosineRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CosineRing{N, M, T} &lt;: VIDA.AbstractImageTemplate</code></pre><p>A flexible symmetric ring model. The thickness is modeled as a cosine expansion with <code>N</code> terms and the slash by a expansion with <code>M</code> terms.</p><p><strong>Details</strong></p><p>The ring is forced to be symmetric for a significant speed boost over CosineRing. The thickness of the ring is modeled by a cosine expansion in azimuthal angle. <code>N</code> specifies the number of cosine modes to fit, where the first mode is the constant thickness portion and so has no corresponding angle. The slash is modeled as a separate cosine expansion, with <code>M</code> terms. Here the zero order term is forced to be unity, so <code>M</code> defines the <code>M</code> additional terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/cosinering.jl#LL3-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.GaussDisk" href="#VIDA.GaussDisk"><code>VIDA.GaussDisk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GaussDisk{T} &lt;: VIDA.AbstractImageTemplate</code></pre><p>A smoothed disk model</p><p><strong>Details</strong></p><p>Defines a template for an image that has a smoothed disk model.</p><p><strong>Fields</strong></p><ul><li><code>α</code>: Disk edge standard deviation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/image.jl#LL102-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.GaussDisk-NTuple{4, Any}" href="#VIDA.GaussDisk-NTuple{4, Any}"><code>VIDA.GaussDisk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GaussDisk(r0, σ, x0, y0)
</code></pre><p>Constructs a disk template with a Gaussian fall off.</p><p><strong>Notes</strong></p><p>This is a convienence constructor that uses <code>VLBISkyModels</code> <code>modify</code> under the hood. To create this function yourself do</p><pre><code class="language-julia hljs">modify(GaussDisk(σ/r0), Stretch(r0), Shift(x0, y0))</code></pre><p><strong>Arguments</strong></p><ul><li><code>r0</code>: Radius of flat top of the disk.</li><li><code>σ</code>:  Standard deviation of the Gaussian of the disk edge.</li><li><code>x0</code>: The horizontal location of the disk center</li><li><code>y0</code>: The vertical location of the disk center</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/image.jl#LL131-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.KullbackLeibler" href="#VIDA.KullbackLeibler"><code>VIDA.KullbackLeibler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct KullbackLeibler{T&lt;:IntensityMap} &lt;: VIDA.AbstractDivergence</code></pre><p>Type for the KL divergence. It constructed from an <code>IntensityMap</code> i.e. data. Additionally to evaluate the divergence we use a functor approach where if θ is your</p><p><strong>Details</strong></p><p>This computes the KL divergence which is related to Hellinger distance between two distributions. In fact, they are both minimized at the same point. The Bhattacharyya divergence is defined as</p><p class="math-container">\[KL(f_\theta||\hat{I}) = -\log\int f_{\theta}(x,y)\log
        \left(\frac{f_{\theta}(x,y)}{\hat{I}(x,y)}\right)dxdy,\]</p><p>where <span>$\hat{I}$</span> is defined as the image normalized to unit flux.</p><p>This struct is also a functor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/divergences.jl#LL137-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.LeastSquares" href="#VIDA.LeastSquares"><code>VIDA.LeastSquares</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LeastSquares{T} &lt;: VIDA.AbstractDivergence</code></pre><p>Type for the least squares divergence. It constructed from an <code>IntensityMap</code> i.e. data. Additionally to evaluate the divergence we use a functor approach where if θ is your</p><p><strong>Details</strong></p><p>This computes the squared 2 norm between your image and template, both of which are normalized to unit flux.</p><p>To construct this just pass it an image object</p><pre><code class="language-julia-repl hljs">julia&gt; ls = LeastSquares(img::IntensityMap)</code></pre><p><strong>Notes</strong></p><p>We have a template internal matrix the prevents internal allocations during computation This is a internal feature that the user does not need to worry about.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/divergences.jl#LL210-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.LogSpiral" href="#VIDA.LogSpiral"><code>VIDA.LogSpiral</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LogSpiral{T&lt;:Real} &lt;: VIDA.AbstractImageTemplate</code></pre><p>Template type for a logarithmic spiral segment</p><p><strong>Fields</strong></p><ul><li><p><code>κ</code>:  Unit curvature of the logarithmic spiral</p></li><li><p><code>σ</code>:  thickness of the Gaussian spiral arm</p></li><li><p><code>δϕ</code>:  Azimuthal extent of the spiral arm</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/image.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.LogSpiral-NTuple{7, Any}" href="#VIDA.LogSpiral-NTuple{7, Any}"><code>VIDA.LogSpiral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LogSpiral(r0, κ, σ, δϕ, ξ, x0, y0)
</code></pre><p>Constructs a <code>LogSpiral</code> template.</p><p><strong>Notes</strong></p><p>This is a convienence constructor that uses <code>VLBISkyModels</code> <code>modify</code> under the hood. To create this function yourself do</p><pre><code class="language-julia hljs">modify(LogSpiral(κ, σ/r0, δϕ),
       Stretch(r0), Rotate(ξ), Shift(x0, y0))</code></pre><p><strong>Arguments</strong></p><ul><li><code>r0</code>: Radius of the start of the logarithmic spiral</li><li><code>κ</code>:  Unit curvature of the spiral</li><li><code>σ</code>:  Thickness of the logarithmic spiral</li><li><code>δϕ</code>: The angular extent of the spiral</li><li><code>ξ</code>:  The position angle of the start of the spiral</li><li><code>x0</code>: The horizontal location of the start of the spiral</li><li><code>y0</code>: The vertical location of the start of the spiral</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/image.jl#LL18-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.NxCorr-Tuple{T} where T&lt;:IntensityMap" href="#VIDA.NxCorr-Tuple{T} where T&lt;:IntensityMap"><code>VIDA.NxCorr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NxCorr(img::IntensityMap)</code></pre><p>Construct the normalized cross correlation (NXCORR) divergence with respect to the image <code>img</code>. To maximize the NXCorr we instead compute the -log(|NxCorr|) as the divergence</p><p>NxCorr is defined as:     NXCORR(n, m) = (Nσₙσₘ) Σᵢ (nᵢ - μₙ)(mᵢ - μₘ) where <code>n</code> and <code>m</code> are the two images <code>μ</code> is the mean and <code>σ</code> is the pixelwise standard deviation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/divergences.jl#LL248-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.RadialDblPower" href="#VIDA.RadialDblPower"><code>VIDA.RadialDblPower</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RadialDblPower(αinner, αouter)</code></pre><p>Radial profile that given by a double power-law with the function form</p><pre><code class="language-julia hljs">    r^αinner*inv(1+ r^(αinner + αouter + 1))</code></pre><p><strong>Notes</strong></p><p>This is usually couple with a azimuthal profile to create a general ring template</p><pre><code class="language-julia-repl hljs">julia&gt; rad = RadialDblPower(3.0, 3.0)
julia&gt; azi = AzimuthalUniform()
julia&gt; t = RingTemplate(rad, azi)</code></pre><p><strong>Arguments</strong></p><ul><li><code>αinner</code> the power law index for <code>r&lt;1</code>.</li><li><code>αouter</code> the power law index for <code>r≥1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/rings.jl#LL91-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.RadialGaussian" href="#VIDA.RadialGaussian"><code>VIDA.RadialGaussian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RadialGaussian(σ)</code></pre><p>Create a profile that is a radial gaussian ring with radius unity and standard deviation <code>σ</code>.</p><p><strong>Notes</strong></p><p>This is usually couple with a azimuthal profile to create a general ring template</p><pre><code class="language-julia-repl hljs">julia&gt; rad = RadialGaussian(0.1)
julia&gt; azi = AzimuthalUniform()
julia&gt; t = RingTemplate(rad, azi)</code></pre><p><strong>Arguments</strong></p><ul><li><code>σ</code>: The standard deviation for the Gaussian ring.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/rings.jl#LL61-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.RadialTruncExp" href="#VIDA.RadialTruncExp"><code>VIDA.RadialTruncExp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RadialTruncExp(σ)</code></pre><p>Radial profile that has a exponential profile up to a cutoff radius of 1 where for <code>r&lt;1</code> the profile is identically zero.</p><p>This evalutes to</p><pre><code class="language-julia hljs">    exp(-(r-1)/σ)</code></pre><p><strong>Notes</strong></p><p>This is usually couple with a azimuthal profile to create a general ring template</p><pre><code class="language-julia-repl hljs">julia&gt; rad = RadialTruncExp(2.0)
julia&gt; azi = AzimuthalUniform()
julia&gt; t = RingTemplate(rad, azi)</code></pre><p><strong>Arguments</strong></p><ul><li><code>σ</code>: Exponential inverse fall off parameter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/rings.jl#LL128-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.Renyi-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:IntensityMap" href="#VIDA.Renyi-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:IntensityMap"><code>VIDA.Renyi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Renyi(img::IntensityMap, α)</code></pre><p>Construct the Renyi divergence with parameter α. It constructed from an <code>IntensityMap</code> i.e. data.</p><p><strong>Details</strong></p><p>This computes the KL divergence which is related to Hellinger distance between two distributions. In fact, they are both minimized at the same point. The Bhattacharyya divergence is defined as</p><p class="math-container">\[Ry(f_\theta||\hat{I}) = \frac{1}{α-1}\log\int
        \left(\frac{f_{\theta}(x,y)^\alpha}{\hat{I}(x,y)^{\alpha-1}}\right)dxdy,\]</p><p>where <span>$\hat{I}$</span> is defined as the image normalized to unit flux.</p><p>This is a very flexible divergence that reduces to many of the other divergences implemented.</p><ul><li><code>α = 1</code> corresponds to the KL divergence</li><li><code>α = 1/2</code> corresponds to the Bhattacharyya divergence up to a multiplicative factor of 2</li></ul><p>Typically we find that <code>α=1.5</code> works well, as it focusses on the bright regions of the images moreso than the Bh and KL divergence. For <code>α&gt;2</code> the measure tends to devolve in something akin the to sup norm and fails to match the image structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/divergences.jl#LL173-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.RingTemplate" href="#VIDA.RingTemplate"><code>VIDA.RingTemplate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RingTemplate{R&lt;:VIDA.AbstractRadial, A&lt;:VIDA.AbstractAzimuthal} &lt;: VIDA.AbstractImageTemplate</code></pre><p>A flexible ring template that forms a ring by taking the product of a radial and azimuthal brightness profile.</p><p>A list of radial profiles is given by <code>subtypes(AbstractRadial)</code></p><p>A list of azimuthal profiles is given by <code>subtypes(AbstractAzimuthal)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rad = RadialGaussian(0.1)
julia&gt; azi = AzimuthalUniform()
julia&gt; ring = modify(RingTemplate(rad, azi), Stretch(10.0), Shift(1.0, 2.0))</code></pre><p><strong>Fields</strong></p><ul><li><code>radial</code>: Radial profile of the ring</li></ul><ul><li><code>azimuthal</code>: Azimuthal profile of the ring</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/rings.jl#LL12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.VIDAMovie" href="#VIDA.VIDAMovie"><code>VIDA.VIDAMovie</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct VIDAMovie{T, F&lt;:(IntensityMap{T, 3, D, A} where {D, A&lt;:AbstractArray{T, 3}}), I&lt;:Interpolations.AbstractExtrapolation} &lt;: VIDA.AbstractMovie</code></pre><p><strong>Details</strong></p><p>Holds a X,Y,T <code>IntensityMap</code> plus an interpolator that lets you make a continuous movie</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/movies.jl#LL7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.VIDAMovie-Union{Tuple{IntensityMap{T, 3, D, A} where {D, A&lt;:AbstractArray{T, 3}}}, Tuple{T}} where T&lt;:Real" href="#VIDA.VIDAMovie-Union{Tuple{IntensityMap{T, 3, D, A} where {D, A&lt;:AbstractArray{T, 3}}}, Tuple{T}} where T&lt;:Real"><code>VIDA.VIDAMovie</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VIDAMovie(mov::IntensityMap{T,3})</code></pre><p>Create an VIDAMovie class for easy interpolation between frames.</p><p><strong>Arguments</strong></p><ul><li><code>mov</code>: An IntensityMap with axes (:X, :Y, :T) that represent the frames of a movie.  Note that the time dimension does not have to be equi-spaced.</li></ul><p><strong>Returns</strong></p><p>An <code>VIDAMovie</code> object that behaves like <code>IntensityMap</code> but lets you interpolate between frames with <a href="#VIDA.get_image-Tuple{VIDAMovie, Any}"><code>get_image(vida_movie, time)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/movies.jl#LL26-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.VIDAProblem" href="#VIDA.VIDAProblem"><code>VIDA.VIDAProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct VIDAProblem{D&lt;:VIDA.AbstractDivergence, F, N, B}</code></pre><p>A composite type that holds various properties that define the optimization process to extract the optimal filter.</p><p><strong>Fields</strong></p><ul><li><code>div</code>: Divergence you will fit</li></ul><ul><li><code>f</code>: Function that defines the parametric family of templates</li></ul><ul><li><code>autodiff</code>: Type of autodiff to use when optimizing if any</li></ul><ul><li><code>lb</code>: The lower bounds of the parameter ranges to search over</li></ul><ul><li><code>ub</code>: The upper bounds of parameter ranges to search over</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/extractor.jl#LL7-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.VIDAProblem-NTuple{4, Any}" href="#VIDA.VIDAProblem-NTuple{4, Any}"><code>VIDA.VIDAProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VIDAProblem(div, f, lb, ub)
</code></pre><p>Defines a <code>VIDAProblem</code> for optimization.</p><p><strong>Arguments</strong></p><ul><li><code>div</code>: The divergence you wish to fit. This is an instantiation of <a href="#VIDA.AbstractDivergence"><code>VIDA.AbstractDivergence</code></a></li><li><code>f</code>:   The function that defines the parametric family of templates you will fit. The function        must accept a named tuple as its first argument, whose names define the parameters.</li><li><code>lb</code>:  A NamedTuple whose names match the argument of <code>f</code> and whose values define the lower        bounds of the parameters range you want to search over</li><li><code>lb</code>: A NamedTuple whose names match the argument of <code>f</code> and whose values define the upper        bounds of the parameters range you want to search over</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f(x) = SlashedGaussianRing(x.σ, x.s)
julia&gt; div = Renyi(img, 0.75)
julia&gt; lb = (x = 0.1, s = 0.001)
julia&gt; ub = (x = 10.0, s = 0.999)
julia&gt; prob = VIDAProblem(div, f, lb, ub)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/extractor.jl#LL39-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ComradeBase.flux-Tuple{Any, Any}" href="#ComradeBase.flux-Tuple{Any, Any}"><code>ComradeBase.flux</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux(mov, t)
</code></pre><p>Returns the flux of the <code>mov</code> at the times <code>time</code> in fractional hours</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/movies.jl#LL116-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.CosineRingwFloor-Union{Tuple{M}, Tuple{N}, Tuple{Any, Any, Tuple{Vararg{T, N}} where T, Tuple{Vararg{T, N}} where T, Tuple{Vararg{T, M}} where T, Tuple{Vararg{T, M}} where T, Any, Any, Any}} where {N, M}" href="#VIDA.CosineRingwFloor-Union{Tuple{M}, Tuple{N}, Tuple{Any, Any, Tuple{Vararg{T, N}} where T, Tuple{Vararg{T, N}} where T, Tuple{Vararg{T, M}} where T, Tuple{Vararg{T, M}} where T, Any, Any, Any}} where {N, M}"><code>VIDA.CosineRingwFloor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CosineRingwFloor(r0, σ0, σ, ξσ, s, ξs, floor, x0, y0)
</code></pre><p>A Cosine ring with a <a href="#VIDA.GaussDisk"><code>GaussDisk</code></a> at the center of the ring that matches the <code>r0</code> and <code>σ0</code> of the CosineRing.</p><p>This is a convienence constructor of the more basic VLBISkyModel image constructors. It is equivalent to</p><pre><code class="language-julia-repl hljs">julia&gt; CosineRing(r0, σ0, σ, ξσ, s, ξs, x0, y0) + floor*modify(GaussDisk(σ0/r0), Stretch(r0), Shift(x0, y0))</code></pre><p><strong>Details</strong></p><p>Adds ellipticity to the ring. The radius <code>r0</code> of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.</p><p>r0 = √(a*b).</p><p>The ellipticity <code>τ</code> is given by τ = 1-b/a.</p><p><strong>Arguments</strong></p><ul><li><code>r0</code>: geometric mean radius (√ab) of the ring</li><li><code>σ0</code>: standard deviation of the Gaussian ring</li><li><code>σ</code> : amplitudes of the <code>N</code> order cosine expansion of the ring thickness</li><li><code>ξσ</code>: phase of the <code>N</code> order cosine expansion of the ring thickness</li><li><code>s</code> : amplitudes of the <code>M</code> order cosine expansion of the azimuthal brightness</li><li><code>ξs</code>: phase of the <code>M</code> order cosine expansion of the azimuthal brightness</li><li><code>floor</code>: The flux of the center Gaussian. This is relative to the CosineRing.</li><li><code>x0</code>: location of the ring center horizontally</li><li><code>y0</code>: location of the ring center vertically</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/cosinering.jl#LL69-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.CosineRingwGFloor-Union{Tuple{M}, Tuple{N}, Tuple{Any, Any, Tuple{Vararg{T, N}} where T, Tuple{Vararg{T, N}} where T, Tuple{Vararg{T, M}} where T, Tuple{Vararg{T, M}} where T, Vararg{Any, 4}}} where {N, M}" href="#VIDA.CosineRingwGFloor-Union{Tuple{M}, Tuple{N}, Tuple{Any, Any, Tuple{Vararg{T, N}} where T, Tuple{Vararg{T, N}} where T, Tuple{Vararg{T, M}} where T, Tuple{Vararg{T, M}} where T, Vararg{Any, 4}}} where {N, M}"><code>VIDA.CosineRingwGFloor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CosineRingwGFloor(r0, σ0, σ, ξσ, s, ξs, floor, σG, x0, y0)
</code></pre><p>A Cosine ring with a Gaussian blob at the center of the ring. This is a convienence constructor of the more basic VLBISkyModel image constructors. It is equivalent to</p><pre><code class="language-julia-repl hljs">julia&gt; CosineRing(r0, σ0, σ, ξσ, s, ξs, x0, y0) + floor*modify(Gaussian(), Stretch(σG), Shift(x0, y0))</code></pre><p><strong>Details</strong></p><p>Adds ellipticity to the ring. The radius <code>r0</code> of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.</p><p>r0 = √(a*b).</p><p>The ellipticity <code>τ</code> is given by τ = 1-b/a.</p><p><strong>Arguments</strong></p><ul><li><code>r0</code>: geometric mean radius (√ab) of the ring</li><li><code>σ0</code>: standard deviation of the Gaussian ring</li><li><code>σ</code> : amplitudes of the <code>N</code> order cosine expansion of the ring thickness</li><li><code>ξσ</code>: phase of the <code>N</code> order cosine expansion of the ring thickness</li><li><code>s</code> : amplitudes of the <code>M</code> order cosine expansion of the azimuthal brightness</li><li><code>ξs</code>: phase of the <code>M</code> order cosine expansion of the azimuthal brightness</li><li><code>floor</code>: The flux of the center Gaussian. This is relative to the CosineRing.</li><li><code>σG</code>: The size of the central Gaussian.</li><li><code>x0</code>: location of the ring center horizontally</li><li><code>y0</code>: location of the ring center vertically</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/cosinering.jl#LL114-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.EllipticalCosineRing-Union{Tuple{M}, Tuple{N}, Tuple{Any, Any, Tuple{Vararg{T, N}} where T, Tuple{Vararg{T, N}} where T, Any, Any, Tuple{Vararg{T, M}} where T, Tuple{Vararg{T, M}} where T, Any, Any}} where {N, M}" href="#VIDA.EllipticalCosineRing-Union{Tuple{M}, Tuple{N}, Tuple{Any, Any, Tuple{Vararg{T, N}} where T, Tuple{Vararg{T, N}} where T, Any, Any, Tuple{Vararg{T, M}} where T, Tuple{Vararg{T, M}} where T, Any, Any}} where {N, M}"><code>VIDA.EllipticalCosineRing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EllipticalCosineRing(r0, σ0, σ, ξσ, τ, ξτ, s, ξs, x0, y0)
</code></pre><p>An Elliptical Cosine ring. This is a convienence constructor of the more basic VLBISkyModel image constructors. It is equivalent to</p><pre><code class="language-julia-repl hljs">julia&gt; modify(CosineRing(σ0/r0, σ/r0, ξσ, s, ξs .- ξτ),
            Stretch(r0*sqrt(1-τ), r0/sqrt(1-τ)),
            Rotate(ξτ),
            Shift(x0, y0)
        )</code></pre><p><strong>Details</strong></p><p>Adds ellipticity to the ring. The radius <code>r0</code> of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.</p><p>r0 = √(a*b).</p><p>The ellipticity <code>τ</code> is given by τ = 1-b/a.</p><p><strong>Arguments</strong></p><ul><li><code>r0</code>: geometric mean radius (√ab) of the ring</li><li><code>σ0</code>: standard deviation of the Gaussian ring</li><li><code>σ</code> : amplitudes of the <code>N</code> order cosine expansion of the ring thickness</li><li><code>ξσ</code>: phase of the <code>N</code> order cosine expansion of the ring thickness</li><li><code>τ</code> : asymmetry of the ring τ = 1-b/a</li><li><code>ξτ</code>: semi-major axis measured east of north</li><li><code>s</code> : amplitudes of the <code>M</code> order cosine expansion of the azimuthal brightness</li><li><code>ξs</code>: phase of the <code>M</code> order cosine expansion of the azimuthal brightness</li><li><code>x0</code>: horizontal location of the ring center</li><li><code>y0</code>: vertical location of the ring center vertically</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/cosinering.jl#LL156-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.EllipticalGaussianRing-NTuple{6, Any}" href="#VIDA.EllipticalGaussianRing-NTuple{6, Any}"><code>VIDA.EllipticalGaussianRing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EllipticalGaussianRing(r0, σ, τ, ξτ, x0, y0)
</code></pre><p>Implements the elliptical gaussian ring template with semi-minor axis <code>a</code> and semi-major axis <code>b</code>.</p><p><strong>Arguments</strong></p><ul><li><code>r0</code>: geometric mean radius (√ab) of the ring</li><li><code>σ</code> : standard deviation of the Gaussian ring</li><li><code>τ</code> : asymmetry of the ring τ = 1-b/a</li><li><code>ξτ</code>: semi-major axis measured east of north</li><li><code>x0</code>: location of the ring center horizontally</li><li><code>y0</code>: location of the ring center vertically</li></ul><p><strong>Notes</strong></p><p>This is a convienence constructor that uses <a href="#VIDA.RingTemplate"><code>RingTemplate</code></a> under  the hood. To create this function your self do</p><p><code>julia  modify(GaussianRing(σ/r0), Stretch(r0*sqrt(1-τ), r0/sqrt(1-τ)), Rotate(ξτ), Shift(x0, y0))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/rings.jl#LL316-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.EllipticalSlashedGaussianRing-NTuple{8, Any}" href="#VIDA.EllipticalSlashedGaussianRing-NTuple{8, Any}"><code>VIDA.EllipticalSlashedGaussianRing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EllipticalSlashedGaussianRing(r0, σ, τ, ξτ, s, ξs, x0, y0)
</code></pre><p>Combination of the elliptical and slashed gaussian ring.</p><p><strong>Details</strong></p><p>Adds ellipticity to the ring. The radius <code>r0</code> of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.</p><p>r0 = √(a*b).</p><p>The ellipticity <code>τ</code> is given by τ = 1-b/a.</p><p>The brightness asymmetry uses a cosine to implement the slash.</p><p><strong>Arguments</strong></p><ul><li><code>r0</code>: geometric mean radius (√ab) of the Gaussian ring</li><li><code>σ</code> : standard deviation of the Gaussian ring</li><li><code>τ</code> : asymmetry of the Gaussian ring τ = 1-b/a</li><li><code>ξτ</code>: semi-major axis measured east of north</li><li><code>s</code> : Slash amplitude. 0 means no slash, and 1 is maximal.</li><li><code>ξs</code>: azimuthal peak brightness P.A. measured east of north</li><li><code>x0</code>: location of the ring center horizontally</li><li><code>y0</code>: location of the ring center vertically</li></ul><p><strong>Notes</strong></p><p>This is a convienence constructor that uses <a href="#VIDA.RingTemplate"><code>RingTemplate</code></a> under  the hood. To create this function your self we define</p><p><code>julia  modify(SlashedGaussianRing(σ/r0, s),             Rotate(ξs-ξτ),             Stretch(r0*sqrt(1-τ), r0/sqrt(1-τ)),             Rotate(ξτ),             Shift(x0, y0)         )</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/rings.jl#LL346-L385">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.GaussianRing-NTuple{4, Any}" href="#VIDA.GaussianRing-NTuple{4, Any}"><code>VIDA.GaussianRing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GaussianRing(r0, σ, x0, y0)
</code></pre><p>Implements the gaussian ring template.</p><p><strong>Notes</strong></p><p>This is a convienence constructor that uses <a href="#VIDA.RingTemplate"><code>RingTemplate</code></a> under the hood. To create this function your self do</p><pre><code class="language-julia hljs">modify(GaussianRing(σ/r0), Stretch(r0), Shift(x0, y0))</code></pre><p><strong>Arguments</strong></p><ul><li><code>r0</code>: radius of the ring</li><li><code>σ</code> : standard deviation of the Gaussian ring</li><li><code>x0</code>: location of the ring center horizontally</li><li><code>y0</code>: location of the ring center vertically</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/rings.jl#LL242-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.GaussianRing-Tuple{Any}" href="#VIDA.GaussianRing-Tuple{Any}"><code>VIDA.GaussianRing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GaussianRing(σ)
</code></pre><p>Implements the gaussian ring template.</p><p><strong>Notes</strong></p><p>This is a convienence constructor that uses <a href="#VIDA.RingTemplate"><code>RingTemplate</code></a> under the hood. To create this function your self do</p><pre><code class="language-julia hljs">RingTemplate(RadialGaussian(σ), AzimuthalUniform())</code></pre><p><strong>Arguments</strong></p><ul><li><code>σ</code> : standard deviation of the Gaussian ring</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/rings.jl#LL223-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.SlashedGaussianRing-NTuple{6, Any}" href="#VIDA.SlashedGaussianRing-NTuple{6, Any}"><code>VIDA.SlashedGaussianRing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SlashedGaussianRing(r0, σ, s, ξ, x0, y0)
</code></pre><p>Implements the slashed gaussian ring template, that uses a cosine to implement the slash.</p><p><strong>Arguments</strong></p><ul><li><code>r0</code>: radius of the ring</li><li><code>σ</code> : standard deviation of the Gaussian ring</li><li><code>s</code> : Slash amplitude. 0 means no slash, and 1 is maximal.</li><li><code>ξs</code>: azimuthal peak brightness P.A. measured east of north</li><li><code>x0</code>: location of the ring center horizontally</li><li><code>y0</code>: location of the ring center vertically</li></ul><p><strong>Notes</strong></p><p>This is a convienence constructor that uses <a href="#VIDA.RingTemplate"><code>RingTemplate</code></a> under the hood. To create this function your self do</p><pre><code class="language-julia hljs">modify(SlashedGaussianRing(σ/r0, s), Stretch(r0), Rotate(ξ), Shift(x0, y0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/rings.jl#LL289-L311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.SlashedGaussianRing-Tuple{Any, Any}" href="#VIDA.SlashedGaussianRing-Tuple{Any, Any}"><code>VIDA.SlashedGaussianRing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SlashedGaussianRing(σ, s)
</code></pre><p>Implements the slashed gaussian ring template, that uses a cosine to implement the slash and has a brightness position angle of 0 degrees east of north.</p><p><strong>Arguments</strong></p><ul><li><code>σ</code> : standard deviation of the Gaussian ring</li><li><code>s</code> : Slash amplitude. 0 means no slash, and 1 is maximal.</li></ul><p><strong>Notes</strong></p><p>This is a convienence constructor that uses <a href="#VIDA.RingTemplate"><code>RingTemplate</code></a> under the hood. To create this function your self do</p><pre><code class="language-julia hljs">RingTemplate(RadialGaussian(σ), AzimuthalCosine((s,), (zero(s),)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/templates/rings.jl#LL266-L285">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.blur-Tuple{SpatialIntensityMap, Any}" href="#VIDA.blur-Tuple{SpatialIntensityMap, Any}"><code>VIDA.blur</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blur(img, fwhm)
</code></pre><p>Blurs the <code>img</code> with a gaussian kernel with fwhm in μas. If <code>fwhm</code> is a scalar then the kernel is assumed to be symmetric, otherwise you the first entry is the fwhm in the EW direction and second the NS direction.</p><p>Returns the blurred image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/images.jl#LL29-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.blur-Tuple{VIDAMovie, Any}" href="#VIDA.blur-Tuple{VIDAMovie, Any}"><code>VIDA.blur</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blur(mov, fwhm)
</code></pre><p>Blurs the <code>mov</code> with a gaussian kernel with fwhm in μas. If <code>fwhm</code> is a scalar then the kernel is assumed to be symmetric, otherwise you the first entry is the fwhm in the EW direction and second the NS direction.</p><p>Returns the blurred movie.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/movies.jl#LL126-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.clipimage" href="#VIDA.clipimage"><code>VIDA.clipimage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">clipimage(clip, image)
clipimage(clip, image, mode)
</code></pre><p>Clips the image <code>im</code> according to the value clip. There are two modes for image clipping:     - <code>:relative</code> which zeros the pixels whose intensity are below <code>clip</code> relative to the max.     - <code>:absolute</code> which zeros the pixels whose intensity is below <code>clip</code> in Jy/pixel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/images.jl#LL3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.divergence-Tuple{VIDA.AbstractDivergence, ComradeBase.AbstractModel}" href="#VIDA.divergence-Tuple{VIDA.AbstractDivergence, ComradeBase.AbstractModel}"><code>VIDA.divergence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">divergence(d, m)
</code></pre><p>Computes the divergence of <code>d</code> with respect to the template <code>m</code>. This measure how similar the divergence with respect to the image stored in <code>d</code> is compared to the template.</p><p><strong>Arguments</strong></p><ul><li><code>d</code>: An divergence or a subtype of <a href="#VIDA.AbstractDivergence"><code>VIDA.AbstractDivergence</code></a></li><li><code>m</code>: A template which <code>ComradeBase.AbstractModel</code> or more commonly      a <a href="#VIDA.AbstractImageTemplate"><code>VIDA.AbstractImageTemplate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/divergences.jl#LL44-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.divergence_point" href="#VIDA.divergence_point"><code>VIDA.divergence_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">divergence_point(div::AbstractDivergence, p, q)</code></pre><p>Evaluate the divergence <code>div</code> at a single pixel with value <code>p</code> and <code>q</code> for image and template. The total divergence</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/divergences.jl#LL27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.get_frames-Tuple{VIDAMovie}" href="#VIDA.get_frames-Tuple{VIDAMovie}"><code>VIDA.get_frames</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_frames(mov)
</code></pre><p>Gets all the frames of the movie object <code>mov</code>. This returns a array of <code>IntensityMap</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/movies.jl#LL107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.get_image-Tuple{VIDAMovie, Any}" href="#VIDA.get_image-Tuple{VIDAMovie, Any}"><code>VIDA.get_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_image(mov, t; keeptime)
</code></pre><p>Gets the frame of the movie object <code>mov</code> at the time t. This returns an <code>IntensityMap</code> object at the requested time. The returned object is found by linear interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/movies.jl#LL95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.get_times-Tuple{VIDAMovie}" href="#VIDA.get_times-Tuple{VIDAMovie}"><code>VIDA.get_times</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_times(mov)
</code></pre><p>Returns the times that the movie object <code>mov</code> was created at. This does not have to be uniform in time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/movies.jl#LL85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.join_frames-Union{Tuple{T}, Tuple{Any, Vector{T}}} where T&lt;:(SpatialIntensityMap)" href="#VIDA.join_frames-Union{Tuple{T}, Tuple{Any, Vector{T}}} where T&lt;:(SpatialIntensityMap)"><code>VIDA.join_frames</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">join_frames(times, images)
</code></pre><p>Joins an array of <code>IntensityMap</code> at specified times to form an VIDAMovie object.</p><p><strong>Inputs</strong></p><ul><li>times: An array of times that the image was created at</li><li>images: An array of IntensityMap objects</li></ul><p><strong>Outputs</strong></p><p>VIDAMovie object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/movies.jl#LL70-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.load_hdf5-Tuple{Any}" href="#VIDA.load_hdf5-Tuple{Any}"><code>VIDA.load_hdf5</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_hdf5(filename; style)
</code></pre><p>Loads an hdf5 file where <code>filename</code> should be a HDF5 file.</p><p><strong>Details</strong></p><p>This reads in a hdf5 file and outputs and EHTMovie object.</p><p><strong>Notes</strong></p><p>Currently this only works with movies created by <em>ehtim</em>. SMILI uses a different format, as does Illinois, and every other group...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/io.jl#LL71-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.load_im_h5-Tuple{String}" href="#VIDA.load_im_h5-Tuple{String}"><code>VIDA.load_im_h5</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_im_h5(fname)
</code></pre><p>where <code>fname</code> should be a hdf5 image file generated using illinois hdf5 process</p><p><strong>Details</strong></p><p>The function returns an IntensityMap object that contains the relevant image and parameters extracted from the fits file. It also ensures that we are astronomers and that the image using sky-left coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/io.jl#LL28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.load_image-Tuple{Any}" href="#VIDA.load_image-Tuple{Any}"><code>VIDA.load_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_image(fname)
</code></pre><p>where <code>fname</code> is a image file. This will call a method based on the file extension. Curerntly we have .fits, and .h5 implemented.</p><p><strong>Details</strong></p><p>This reads in a fits file that is more robust to the various imaging algorithms in the EHT, i.e. is works with clean, smili, eht-imaging.</p><p>The function returns an <code>IntensityMap</code> object that contains the relevant image and parameters extracted from the fits file. It also ensures that we are astronomers and that the image using sky-left coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/io.jl#LL2">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.normalize_div" href="#VIDA.normalize_div"><code>VIDA.normalize_div</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize_div(div, val)</code></pre><p>Returns the proper divergence whose values have been normalized so that the value is always postive semi-definite and is only zero then the template and the image are equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/divergences.jl#LL35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.nxcorr-Union{Tuple{T}, Tuple{IntensityMap{T, N, D, A} where {N, D, A&lt;:AbstractArray{T, N}}, IntensityMap{T, N, D, A} where {N, D, A&lt;:AbstractArray{T, N}}}} where T&lt;:Real" href="#VIDA.nxcorr-Union{Tuple{T}, Tuple{IntensityMap{T, N, D, A} where {N, D, A&lt;:AbstractArray{T, N}}, IntensityMap{T, N, D, A} where {N, D, A&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><code>VIDA.nxcorr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nxcorr(img1, img2)
</code></pre><p>Returns the normalized cross correlation (NXCORR) between <code>img1</code> and <code>img2</code>. NXCORR is defined as</p><pre><code class="nohighlight hljs">NXCORR(n, m) = (Nσₙσₘ) Σᵢ (nᵢ - μₙ)(mᵢ - μₘ)</code></pre><p>where <code>n</code> and <code>m</code> are the two images <code>μ</code> is the mean and <code>σ</code> is the pixelwise standard deviation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/divergences.jl#LL266-L275">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.save_hdf5-Tuple{Any, Any}" href="#VIDA.save_hdf5-Tuple{Any, Any}"><code>VIDA.save_hdf5</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">save_hdf5(filename, mov; style)
</code></pre><p>Saves and hdf5 file where <code>filename</code> is the write out location. Currently style only works with ehtim, namely we save HDF5 files that only work with ehtim.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/io.jl#LL90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.triptic" href="#VIDA.triptic"><code>VIDA.triptic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">triptic(img::SpatialIntensityMap, template)</code></pre><p>Plots a triptic where the left panel is the <code>img</code> middle the <code>template</code> and the right a two cross-sections of the image and template</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/visualizations.jl#LL1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VIDA.vida-Tuple{VIDAProblem, Any}" href="#VIDA.vida-Tuple{VIDAProblem, Any}"><code>VIDA.vida</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vida(
    prob,
    optimizer;
    rng,
    init_params,
    unit_cube,
    kwargs...
)
</code></pre><p>Runs the <code>VIDA</code> algorithm to find the optimal template defined by the problem <code>prob</code>. The optimization will be run using the <code>Optimization.jl</code> <code>optimizer</code>. You can optionally pass a random number generator used to specify the initial points or can explicitly pass the initial location of the optimization using <code>init_params</code>. By default <code>vida</code> first transforms the parameter space to the unit hypercube. If you do not wish to do this set <code>unit_cube = false</code>.</p><p>The remaining <code>kwargs...</code> are forwarded to the <code>Optimization.solve</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>prob</code>: Defines the problem you wish to solve.</li><li><code>optimizer</code>: Specifies the optimizer you want to use. Any optimizer from <code>Optimization.jl</code> works.</li></ul><p><strong>Optional Keyword arguments</strong></p><ul><li><code>rng</code>: Specifies the random number generator you want to use to select the initial points.        Note that is not forwarded to the optimizers since not all can use a specific rng.</li><li><code>init_params</code>: Specify the initial point of the optimization routine. The default <code>nothing</code>                will randomly draw a starting point from the parameter space</li><li><code>unit_cube</code>: If true the parameters are first transformed to the unit hypercube. If false              they are transformed to ℝⁿ using <code>TransformVariables</code></li><li><code>kwargs...</code>: Additional options to be passed to the <code>solve</code> function from <code>Optimization.jl</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/extractor.jl#LL110-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLBISkyModels.regrid-Tuple{VIDAMovie, RectiGrid{&lt;:Tuple{var&quot;#s51&quot;, var&quot;#s50&quot;} where {var&quot;#s51&quot;&lt;:X, var&quot;#s50&quot;&lt;:Y}}}" href="#VLBISkyModels.regrid-Tuple{VIDAMovie, RectiGrid{&lt;:Tuple{var&quot;#s51&quot;, var&quot;#s50&quot;} where {var&quot;#s51&quot;&lt;:X, var&quot;#s50&quot;&lt;:Y}}}"><code>VLBISkyModels.regrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">regrid(mov::VIDAMovie, npix, xlim, ylim)</code></pre><p><strong>Inputs</strong></p><ul><li>mov::VIDAMovie : Movie you want to regrid</li><li>npix : Number of pixels in x and y direction</li><li>xlim : Tuple with the limits of the image in the RA</li><li>ylim : Tuple with the limits of the image in DEC</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/ad5d9c6d81b0bdd4e557971485aa9e045b4d8c7e/src/movies.jl#LL141-L148">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../generated/custom_template/">« Adding a Custom Template</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Tuesday 30 April 2024 16:33">Tuesday 30 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
